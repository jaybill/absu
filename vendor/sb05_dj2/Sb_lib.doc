              =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
              -                                            =
              = The Sound-Blaster Library for DJGPP v2     -
              -                                            =
              =               Version 0.5                  -
              -                                            =
              =     Copyright (C) 1995, Joel H. Hunter     -
              -                                            =
              =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



|\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|
|  Special thanks to Eric Jorgensen, author of Varmint's Audio Tools,  without |
|whom this library would not have been possible.  Varmint's Audio Tools (VAT)  |
|is a versatile freeware Sound-Blaster library for Borland/Turbo C++, which    |
|used to be based on code by Peter Sprenger, but has since grown independently.|
|  The Sound-Blaster Library for DJGPP V. 2.0 is based in part on VAT.  You    |
|can obtain VAT at mack.rt66.com/users/smeagol/vatxxx.zip, and can contact Eric|
|at smeagol@rt66.com.                                                          |
|\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|



  Legal Stuff:

  1> The Sound-Blaster Library for DJGPP V. 2.0 is copyrighted freeware.  
     You are free to do with it as you please, with the following conditions:
       a) If you change/add to/make better this library, send me your changes!
          I will maintain all such patches, and re-release a new, better
          library that everyone can enjoy and will benefit from!
       b) If you create a new library based on this library, give Eric and I
          credit, and maintain this freeware policy.
       c) You MAY use this library in a commercial/shareware application,
          however, please let me know about it, give me a little credit,
          and send me a copy.
  2> USE OF THIS LIBRARY IS STRICTLY AT YOUR OWN RISK!  THE AUTHOR ASSUMES NO
     RESPONSIBILITY FOR TIME, MONEY, AND/OR EQUIPMENT LOST DUE TO THE USE
     OF THIS LIBRARY.
  3> THIS LIBRARY IS NOT GUARANTEED TO WORK SAFELY ON ANY COMPUTER!
  4> THIS LIBRARY IS NOT GUARANTEED TO BE SUITABLE FOR ANY SPECIFIC PURPOSE.
  5> IF THE ABOVE RESTRICTIONS DO NOT CONFORM TO THE LAWS OF YOUR STATE, YOU
     MUST NOT USE THIS LIBRARY.



=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -        WHAT IS IT?
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  This library is an application programming interface (API) for programming
the family of Sound-Blaster sound cards.  Here is a short list of features:

   *  Background 4/6/8-channel stereo .MOD player (no S3M yet).

   *  The driver can be run at different sampling rates (5KHz to 45 KHz.)  This
      allows for clearer sample and .MOD playing.  A function to convert
      samples from one frequency to another (without changing pitch) is
      provided.

   *  Real-time sample-mixing in stereo.  Up to 16 samples can be mixed at a
      time.  This allows programs to start a new sound playing before an old
      one has finished.  Sound can be played in the left, right, or both
      speakers.

   *  Stereo panning.  The application can modify the left/right speaker
      volumes of individual samples gradually, while the sample is still being
      played.  This allows for various stereo effects, such as the sound of
      a door closing moving from one speaker to another as a player turns
      (ala Wolfenstein 3D.)

   *  Sample-queuing.  If you have a sample that is broken up into several
      pieces, you can queue them all at once, and the library will play
      them back in order, one after the other.

   *  End-of-sample callbacks.  If your program needs to be made aware that a
      sample has finished playing, you can define a callback function, which
      the library will call when the given sample is finished.

   *  Several sample-file-formats.  Currently 3 separate sample file-formats
      are supported.  They are: raw (no header), .VOC (old-style only), and
      .WAV.

   *  Stereo sounds are consildated to a single channel on Sound-Blaster cards
      which don't support stereo sound.


=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -     TELL ME ABOUT THE DRIVER
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  In order to use the driver, simply #include "sb_lib.h" in your program, and
when compiling add 'libsb.a' to your command line
(e.g. gcc -o myprog myprog.c libsb.a -lemu).
  All global symbols used by this library are prefixed with 'sb_'.  This is
to avoid any conflicts with the calling application.
  Communication with the driver functions frequently involve the use of
structures defined in the SB_DEFS.H header, or pointers to such structures.
Here are some of the structure definitions:

   *  typedef struct {
        char title[20];
        sb_mod_instrument *instrument;
        BYTE songLength;
        BYTE CIAA;
        BYTE arrangement[128];
        BYTE id[4];
        BYTE *patternBuffer;
        int modSamples;
        int modChannels;
      } sb_mod_file;

   *  typedef struct {
        BYTE *data;                     /* Pointer to the sample data */
        int length;                     /* Length, in bytes, of sample data */
        int stereo;                     /* Not implemented yet. */
        int bits;                       /* Not implemented yet. */
        int left_volume;                /* Volume for left speaker (0-64) */
        int right_volume;               /* Volume for right speaker (0-64) */
        void (*callback)();             /* Callback function */
      } sb_sample;

   *  typedef enum {
        SB_SUCCESS,
        SB_FAILURE,
        SB_BAD_BLASTER,
        SB_BAD_ADDRESS,
        SB_BAD_IRQ,
        SB_BAD_DMA,
        SB_BAD_FILE,
        SB_BUSY,
        SB_BAD_POINTER
      } sb_status;


  Normally you will not modify the contents of such structures directly.
Rather, function calls you make to the library will fill/interpret these
structures.  The only exception to this is the sb_sample structure, which
contains the left_volume and right_volume members.  To keep performance
optimal, stereo-panning can be accomplished by the calling application
by directly manipulating these values.
  The sb_status enumerated type is used to gather information about the
success or failure of certain functions.  Often, however, functions return
pointers to structures (such as the sb_sample or sb_mod_file structures) and
therefore can not return an sb_status symbol.  In addition, the sb_status
enumerated type does not always tell the whole story.  Therefore it is
necessary to maintain a few strings which contain detailed descriptions of
problems, should a function return an error value.  These strings
(character pointers) are named:
    char sb_driver_error[80];   /* For problems occuring at initialization */
    char sb_digi_error[60];     /* For problems relating to individual samples */
    char sb_mod_error[60];      /* For problems relating to the .MOD player. */
In the future, these strings may be consolidated into a single error string,
but for now I have kept them separate.
  IMPORTANT: As of version 0.2, floating-point calculations are used in
some initialization functions.  As a result, you should ALWAYS link in the
floating-point emulation library (-lemu) when using this library (unless, of
course, you are going to make your program require a 486-DX.)
   

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -      INITIALIZATION SYMBOLS
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  * sb_status sb_install_driver(int samplingRate);

      This function returns an sb_status enumerated type.  If the value
    returned is not 'SB_SUCCESS', look in the sb_driver_error string for a
    concise description of what went wrong.
      Driver initialization is accomplished with a call to sb_install_driver().
    It is important that the calling application initialize the driver before
    doing any timing-critical operations, such as calibrating a joystick.  This
    is because the driver entails a certain amount of overhead, and your CPU
    will therefore act slightly slower after driver initialization than it did
    before initialization.
      The severity of this effect is determined by what sampling rate you
    choose to install the driver at.  This value is passed to
    sb_install_driver(), and should be between 5000 and 45454.  Higher sampling
    rates require more CPU time.  It is recommended that the calling
    application have some sort of 'SETUP' program, so the user can choose his
    own sampling rate based on how fast his CPU is.  You may want to present
    the user with a table of recommendations, like this:
               386 33-40: 11000 Hz
               486-DX 33: 22050 Hz
               486-DX2  : 44100 Hz
      I have noticed that on older Sound-Blaster cards, not all sampling rates
    'work.'  I recommend sticking to the 'standard' ones listed above.
      Not all sound-cards support the full range of sampling rates.  However,
    if a sampling rate is chosen that is not supported by the installed card,
    the library will automatically choose the nearest available sampling rate.
    This brings us to the next symbol:


  * int sb_sample_frequency;

      Since the sampling rate requested to the sb_install_driver() function may
    not be available in a particular setup, this symbol is available to find
    out the sampling rate actually being used by the driver.  This is really
    only necessary to the sb_convert_frequency() function, discussed later.


  * void sb_change_dma_channel(int newChannel);

      The library is unable to detect which DMA channel is in use by the
    currently installed Sound-Blaster card (Address and IRQ values ARE
    detected.)  Therefore it is necessary to provide the ability for the
    calling application to override the defualt DMA channel value, which is 1
    (almost all Sound-Blaster cards use DMA channel 1.)
      It is recommended that the calling application have a 'SETUP' program,
    in which the user can specify his DMA channel.  Then the calling
    application can use this function to pass on the user's DMA channel to the
    library.  Note that this function MUST be called BEFORE the
    sb_install_driver() function if this method is used!
      Another option is to request the user setup the BLASTER environment
    variable with the complete information on his sound-card, in which case the
    library will use the value given there by default.


  * void sb_uninstall_driver(void);
  
      This function unhooks all interrupts and resets the Sound-Blaster card,
    effectively uninstalling the driver.  Note, however, you are responsible
    for  freeing all of the samples and/or mod files you may have loaded
    (functions are provided to do this, but you must call them!)



=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -     DIGITAL SAMPLE SYMBOLS
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  *  sb_sample *sb_load_sample(char *fileName, int fileType);

       This function is used to allocate and fill an sb_sample structure.  The
     first argument, 'fileName' is a NULL-terminated string containing the full
     name of the sample file to load.
       The second argument, 'fileType', is one of the following constants:
        * _SB_RAW
        * _SB_VOC
        * _SB_WAV
     Passing a value other than one of these will result in an error.
       If the pointer returned is the NULL pointer, you can find a concise
     description of what went wrong in the global string sb_digi_error.
       This function automatically sets the sample callback function to NULL
     (no callback) and sets the left_volume and right_volume both to 32, the
     normal volume of the sample.
       This function was designed so there was a bit of similarity between it
     and the familiar 'fopen()' function.  See the example.

     Example:
       sb_sample *gunshot;      /* Note you only allocate a pointer, NOT an */
       FILE *nothing;           /* instance of the structure.               */

       gunshot=sb_load_sample("gunshot.voc",_SB_VOC);
       nothing=fopen("nothing.bin","rb");
       if(gunshot==NULL) {
         fprintf(stderr,"Sample error: %s\n\n",sb_digi_error);
         exit(1);
       }


  *  void sb_mix_sample(sb_sample *sampleName);

       This function immediately adds a sample to the mix of whatever other
     samples might be playing at the time.
       The pointer passed should be a pointer to a sample loaded with the
     sb_load_sample() function.  If the 'void (*callback)()' member of the
     sb_sample structure is not NULL, then the function it points to will be
     called when the sample finishes.  If you wish to define a callback for
     a sample, do so after loading the sample with the sb_load_sample()
     function.
       Any modifications to the left_volume and right_volume members of the
     sb_sample structure while the sample is playing will be heard immediately.
     Note that 32 is the 'normal' volume for both of these variables.  Values
     higher than 32 (i.e. up to 64) can be used, but may result in the
     distortion of the sample.
       It is up to the calling application to make sure a volume greater than
     64 is not used.  It is my belief that it is better to trust the calling
     application to behave itself than to slow down the entire driver by
     constantly double-checking the sensitive variables.

     Example:
     void myCallback(void) {
       sampleIsFinished++;
     }

     void main(void) {
       sb_sample *a_sample;
       int a;
       sb_status stat=sb_install_driver(11000);

       if(stat==SB_SUCCESS) {
         a_sample=sb_load_sample("boom.raw",_SB_RAW);
         if(a_sample!=NULL) {

           sampleIsFinished=0;
           a_sample.callback=myCallback;

           sb_mix_sample(a_sample);
           for(a=32;a>=0;a++) {
             a_sample->left_volume=a;
             delay(2);
           }
           sleep(1);
           sb_mix_sample(a_sample);

           while(sampleIsFinished<2);

           sb_free_sample(a_sample);
         }
         sb_uninstall_driver();
       }
     }


  *  sb_status sb_queue_sample(sb_sample *sampleName);

       This function queues up a sample.  If no other samples are queued at
     the time, the sample will begin playing immediately.
       Make sure and read the notes about the callback function and the
     left_volume and right_volume in the sb_mix_sample() text above.  The
     same applies to this function.
       Queued samples are played indpendantly of mixed samples, and the two
     do not effect each other (unless you queue and mix the same sample.)

     Example:
     sb_sample *section[3];

     section[0]=sb_load_sample("part1.wav",_SB_WAV);
     section[1]=sb_load_sample("part2.wav",_SB_WAV);
     section[2]=sb_load_sample("part3.wav",_SB_WAV);

     sb_queue_sample(section[0]);
     sb_queue_sample(section[1]);
     sb_queue_sample(section[2]);

     go_do_something_interesting_while_all_3_samples_play_in_sequence();


  *  sb_sample *sb_convert_frequency(sb_sample *source, int sourceFrequency,
                                                        int destFrequency);

       This function was designed for a specific scenario:
     The calling application wishes to install the driver at the maximum
     sampling rate (45454 Hz) so that the .MOD file plays with the highest
     clarity.  However, the calling application also wishes to mix in samples
     from time to time, and the samples it wishes to use have been recorded
     at 11000 Hz.  If played normally, they would seem to be much higher in
     pitch.
       Therefore this function is provided as a way to convert samples recorded
     at one frequency to another frequency, without pitch distortion.
     Conversion can be from a lower frequency to a higher one, or from a higher
     frequency to a lower one.  This function uses 64-bit fixed-point math
     to do the conversion, so should be relatively fast on any computer.
       Note that this function creates a new sample, it does NOT delete the
     source sample.  If you want the source sample deleted, you should do it
     yourself with the sb_free_sample() function.

     Example:
     sb_sample *original;
     sb_sample *converted;
     sb_stat status=sb_install_driver(44100); /* May not get this rate though! */

     original=sb_load_sample("boom.wav",_SB_WAV);
     converted=sb_convert_frequency(original,11000,sb_sample_frequency);
                                              /*   ^^^^^^^^^^^^^^^^^^^  */
                                /* Use this variable instead of passing 44100! */
     sb_free_sample(original);
     go_do_something_exciting();
     sb_free_sample(converted);         /* Don't forget to do this! */
     


  *  void sb_free_sample(sb_sample *sampleName);

       This function frees the memory previously allocated by the
     sb_load_sample() function.

     Example:
     sb_sample *sample;

     sample=sb_load_sample("onetimer.voc",_SB_VOC);
     sb_mix_sample(sample);

     getch();

     sb_free_sample(sample);




=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -        MOD PLAYER SYMBOLS
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  *  sb_mod_file *sb_load_mod_file(char *modFileName);

       This function loads a .MOD file, and returns a pointer to a structure
     containing the data on the .MOD file needed by the player.
       If the value returned is the NULL pointer, look to the sb_mod_error
     string for a concise description of what went wrong.

     Example:
     sb_mod_file *myMod;

     myMod=sb_load_mod_file("neato.mod");
     if(myMod==NULL) {
       fprintf(stderr,"MOD error: %s\n\n",sb_mod_error);
       exit(1);
     }


  *  void sb_mod_play(sb_mod_file *modFile);

       This function starts the mod 'modFile' (which should have been loaded
     previously with the sb_load_mod_file() function) playing.  Make sure
     you have run sb_install_driver() before trying to play a .MOD.

     Example:
     sb_mod_file *myMod;

     myMod=sb_load_mod_file("neato.mod");
     if(myMod==NULL) {
       fprintf(stderr,"MOD error: %s\n\n",sb_mod_error);
       exit(1);
     }

     sb_install_driver(45454);
     sb_mod_play(myMod);
     while(sb_mod_active);
     sb_free_mod_file(myMod);
     sb_uninstall_driver();


  *  void sb_mod_pause(void);

       This pauses .MOD file playback.


  *  void sb_mod_resume(void);

       This resumes .MOD playback after a call to sb_mod_pause();


  *  int sb_mod_active;

       This variable indicates whether a .MOD file is currently playing or
     not.  The calling application may want to check the value of this
     variable every now and then to see if the .MOD has finished playing.
       A zero indicates no .MOD is playing, non-zero indicates a .MOD is
     playing.
       Note that calling sb_mod_pause() also sets this variable to zero,
     and sb_mod_resume() also sets it to non-zero.


  *  int sb_mod_volume;

       The calling application has direct access to a possibly dangerous
     variable here.  This variable indicates how loudly the .MOD file will
     be played.  This is used because older Sound-Blaster cards have no
     built-in mixers, and therefore there is no easy way to reduce/increase
     the volume.
       The calling application should excercise great caution when modifying
     this variable.  The value it holds should not be allowed to exceed 14
     or to become less than 2.  Lower values will raise the volume of the
     .MOD, while higher values will lower the volume.  The default volume is
     7.
       Note that attempting to raise the volume significantly (values less
     than 5) will result is severe distortion.  This variable is primarily
     for use in DECREASING the volume.


  *  void sb_free_mod_file(sb_mod_file *modToFree);

       This function frees memory allocated to hold a .MOD file.  The calling
     application should use this function to free every sb_mod_file structure
     allocated with the sb_load_mod_file() function.



=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -       CUSTOMIZED VERSIONS
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  The library is currently being distributed with 3 makefiles: STANDARD.MAK,
SB_TEST.MAK, and BAREBONZ.MAK.  The makefiles represent the fact that certain
elements of library may be unnecessary to a given application, and therefore
need not be linked into the exectuable.
  STANDARD.MAK builds a version of LIBSB.A which includes all the features of
the library, but does not link in the debugging functions of the MOD player.
  SB_TEST.MAK builds the SB_TEST.EXE program, including all code needed to
do so.
  BAREBONZ.MAK builds a version of LIBSB.A which includes ONLY the code to
mix and queue samples.  This is basically the smalles version of LIBSB.A which
still retains the library's functionality.  
  The following symbols define which optional elements are linked into the
library file, LIBSB.A:

  _SB_INCLUDE_MOD              : Include the .MOD player, and all of it's
                                 related functions, into the library.
  _SB_INCLUDE_FILE_UTILS       : Include the sample-loading function,
                                 sb_load_sample, and it's related functions.
  _SB_INCLUDE_CONVERSION_UTILS : Include the function to convert samples from
                                 one frequency to another, without changing
                                 pitch (sb_convert_frequency()).
  _SB_MOD_SHOW_INFO            : Include the debugging functions of the MOD
                                 player, which print out values of key
                                 variables as the .MOD file is playing.
                                 Normally, you would only define this symbol
                                 when recompiling the sb_test program.




=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-                                            =
= The Sound-Blaster Library for DJGPP V. 2.0 -       I HAVE SOME QUESTIONS!
-                                            =
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  I welcome any questions or comments about this library, but keep in mind this
library is still in beta.  I have done all that I can to make this a useful,
professional library, but there may be features you want that aren't in it.
Let me know.  I can currently be reached at:

    jhunter@kendaco.telebyte.net
